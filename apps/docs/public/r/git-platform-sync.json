{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "git-platform-sync",
  "type": "registry:block",
  "title": "Git Platform Sync",
  "description": "A component that implements repo syncing between code.storage and git platforms like GitHub.",
  "registryDependencies": [
    "button",
    "command",
    "field",
    "input",
    "popover",
    "select",
    "tooltip"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/git-platform-sync/git-platform-sync.tsx",
      "content": "import { Button } from '@/components/ui/button';\nimport { Field, FieldLabel } from '@/components/ui/field';\nimport { Input } from '@/components/ui/input';\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover';\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from '@/components/ui/tooltip';\nimport { cn } from '@/lib/utils';\nimport * as PopoverPrimitive from '@radix-ui/react-popover';\nimport { AlertCircle, BookOpen, ChevronDown, Loader2 } from 'lucide-react';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\n\nimport { ComboBox } from './combobox';\nimport {\n  type GitHubConnectionStatus,\n  useGitHubAppConnection,\n} from './github/github-app-connect';\nimport { GitHubIcon } from './github/icon';\nimport { generateOwnerOptions, useOwners } from './github/owners';\n\n// TODO: determine if this is the canonical way to import other components inside of a block\n\nexport type Step = 'welcome' | 'create' | 'manage';\n\nexport type RepositoryData = {\n  /**\n   * @description The owner of the repository, also referred to as the 'scope' - usually\n   * the username of the user or an organization they belong to.\n   */\n  owner?: string;\n  /**\n   * @description The name of the repository, this is a 'slug' style name.\n   */\n  name?: string;\n  /**\n   * @description The branch of the repository, this is the branch that will be used to sync\n   */\n  branch?: string;\n};\n\nexport type SyncedRepo = {\n  url: string;\n  repository: {\n    owner: string;\n    name: string;\n    defaultBranch: string;\n  };\n};\n\nexport type GitPlatformSyncStatus =\n  | 'disconnected'\n  | 'connected'\n  | 'connected-syncing'\n  | 'connected-warning';\n\n/**\n * @description Platforms that code.storage supports\n */\nexport type SupportedGitPlatform = 'github';\nexport type PlatformConfig_GitHub = {\n  platform: 'github';\n  slug: string;\n  redirectUrl?: string;\n};\n// Currently only github configs are allowed, but in the future more\n// may be supported\nexport type PlatformConfigObject = PlatformConfig_GitHub;\n\nexport type GitPlatformSyncProps = {\n  /**\n   * @description List of supported platforms that you want to offer to the user. We recommend\n   * not setting this until we support more platforms.\n   */\n  platforms: PlatformConfigObject[];\n\n  /**\n   * @default 'icon-only'\n   * @description Variant display of the button that opens the sync popover. The\n   * `icon-grow` variant will appear as the `icon` variant until hovered or focused,\n   * and then grow to appear as the `full` variant.\n   */\n  variant?: 'icon-only' | 'icon-grow' | 'full';\n\n  /**\n   * @default true\n   * @description Whether to show the sync indicator in the button, e.g. the little colored dot\n   */\n  showSyncIndicator?: boolean;\n\n  /**\n   * @default 'end'\n   * @description The alignment of the popover content\n   */\n  align?: React.ComponentProps<typeof PopoverContent>['align'];\n\n  /**\n   * @default 'auto'\n   * @description This controls the status dot that appears in the button. If `auto` is set, then\n   * the component will determine either `disconnected` or `connected`. However, an implementor may\n   * choose to override this as `connected-syncing` or `connected-warning`. Note that the component\n   * will not verify that the status is valid, it will faithfully render the status you provide.\n   */\n  status?: 'auto' | GitPlatformSyncStatus;\n\n  /**\n   * @description Control the open state of the popover\n   */\n  open?: boolean;\n\n  /**\n   * @description This directly sets the name of the repository that will be created. Setting this\n   * will take precedence over the `defaultName` option. Users will not be able to change from this\n   * name.\n   */\n  repoName?: string;\n\n  /**\n   * @description If you'd like to suggest a name for the repository, but allow the user to customize it,\n   * this is the initial value of the repository name field. This will be ignored if the `name` option is\n   * set.\n   */\n  repoDefaultName?: string;\n\n  /**\n   * @default 'unique-repo-name…'\n   * @description The placeholder text for the repository name field. This will be invisible if the `name`\n   * or `defaultName` option is set, but if the user erases the defaultName it will be shown.\n   */\n  repoNamePlaceholder?: string;\n\n  /**\n   * @default 'main'\n   * @description The branch that will be used to sync within the repository. `main` is used if this is not\n   * provided.\n   */\n  repoDefaultBranch?: string;\n\n  /**\n   * @description Callback for controlled usage of the the repository name input. Fires\n   * the same as the 'onChange' event of the input.\n   */\n  onRepoNameChange?: (repoName: string) => void;\n\n  /**\n   * @description callback for the change event of the repo owner combobox. Since this\n   * input cannot be controlled, this callback is just for being informed of changes.\n   */\n  onOwnerChange?: (owner: string) => void;\n\n  /**\n   * @description Callback when a user clicks the 'Create Repository' button with valid\n   * data selected. This is where you will hook into the the code storage endpoints in your app.\n   */\n  onRepoCreateAction?: (repoData: RepositoryData) => void;\n\n  /**\n   *\n   * @description Callback when the user clicks the 'Help me get started' button. If this callback is\n   * not provided, the 'Help me get started' button will not be shown.\n   */\n  onHelpAction?: () => void;\n\n  /**\n   * @description Callback when the popover is opened.\n   */\n  onOpenChange?: (isOpen: boolean) => void;\n\n  /**\n   * @description The repository that has been synced to code.storage. This is used to\n   * display the repository information in the popover. If this is provided, the user will\n   * immediately see the syncing page, rather than the welcome or connection page.\n   * Set this as a result of the `onRepoCreateAction` callback.\n   */\n  codeStorageRepo?: SyncedRepo;\n\n  /**\n   * @deprecated Internal use only, not guaranteed to be supported in the future\n   * @description The container to render the popover portal in, only used for docs. This requires\n   * modifying the shadcn Popover component to accept a container prop for the portal\n   */\n  __container?: React.ComponentProps<\n    typeof PopoverPrimitive.Portal\n  >['container'];\n};\n\nexport function GitPlatformSync({\n  platforms,\n  variant = 'icon-only',\n  align = 'end',\n  status: statusProp = 'auto',\n  repoName,\n  repoDefaultName,\n  repoNamePlaceholder,\n  repoDefaultBranch = 'main',\n  onHelpAction,\n  onRepoCreateAction,\n  onOpenChange,\n  onRepoNameChange,\n  onOwnerChange,\n  codeStorageRepo,\n  open,\n  __container,\n}: GitPlatformSyncProps) {\n  const [isPopoverOpen, setIsPopoverOpen] = useState(open ?? false);\n  const [isTooltipOpen, setIsTooltipOpen] = useState(false);\n  const codeStorageRepoExists = !!codeStorageRepo;\n\n  const status = useMemo(() => {\n    if (statusProp === 'auto') {\n      if (codeStorageRepoExists) {\n        return 'connected';\n      } else {\n        return 'disconnected';\n      }\n    }\n    return statusProp;\n  }, [statusProp, codeStorageRepoExists]);\n\n  // We want to make sure the container internal stuff doesn't blow up anyone's types\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const containerProp: any = __container ? { container: __container } : {};\n\n  let platformName: string | undefined;\n  let platformConfig: PlatformConfigObject | undefined;\n\n  const handleOpenChange = useCallback(\n    (isOpen: boolean) => {\n      setIsPopoverOpen(isOpen);\n      if (isOpen) {\n        onOpenChange?.(true);\n      } else {\n        onOpenChange?.(false);\n      }\n    },\n    [onOpenChange]\n  );\n\n  if (platforms.length === 0) {\n    throw new Error('No platforms provided to GitPlatformSync');\n  }\n\n  if (platforms.length === 1 && platforms[0].platform === 'github') {\n    platformName = 'GitHub';\n    platformConfig = platforms[0];\n  } else {\n    throw new Error(\n      'Currently GitPlatformSync only supports a single GitHub platform'\n    );\n  }\n\n  const {\n    handleConnect,\n    status: connectionStatus,\n    fetchInstallationStatus,\n    destroy: destroyGitHubAppConnection,\n  } = useGitHubAppConnection({\n    slug: platformConfig.slug,\n    redirectUrl: platformConfig.redirectUrl,\n  });\n\n  useEffect(() => {\n    fetchInstallationStatus();\n  }, [fetchInstallationStatus]);\n\n  useEffect(() => {\n    return () => {\n      destroyGitHubAppConnection();\n    };\n  }, [destroyGitHubAppConnection]);\n\n  const labelText = `Sync to ${platformName}`;\n\n  // If we don't have any label inside the button we should set an aria-label\n  // that describes what that button does.\n  const buttonAriaLabelProp =\n    variant === 'icon-only'\n      ? {\n          'aria-label': labelText,\n        }\n      : {};\n\n  const PopoverConductorProps: PopoverConductorProps = {\n    align,\n    __container,\n    onHelpAction,\n    onRepoCreateAction,\n    repoName,\n    repoDefaultName,\n    repoNamePlaceholder,\n    repoDefaultBranch,\n    onRepoNameChange,\n    onOwnerChange,\n    handleConnect,\n    connectionStatus,\n    codeStorageRepo,\n  };\n\n  // TODO: fix full button, and disable tooltip on open popover\n  return (\n    <Popover open={isPopoverOpen} onOpenChange={handleOpenChange}>\n      {variant === 'icon-only' ? (\n        <>\n          <Tooltip\n            open={isPopoverOpen ? false : isTooltipOpen}\n            onOpenChange={setIsTooltipOpen}\n            delayDuration={800}\n          >\n            <TooltipTrigger asChild>\n              <PopoverTrigger asChild>\n                <BaseSyncButton {...buttonAriaLabelProp} status={status} />\n              </PopoverTrigger>\n            </TooltipTrigger>\n            <TooltipContent {...containerProp}>{labelText}</TooltipContent>\n          </Tooltip>\n          <PopoverConductor {...PopoverConductorProps} />\n        </>\n      ) : (\n        <>\n          <PopoverTrigger asChild>\n            <BaseSyncButton\n              {...buttonAriaLabelProp}\n              className=\"gap-0\"\n              status={status}\n            >\n              <span\n                className={cn(\n                  'justify-between items-center gap-1.5 text-foreground transition-width delay-200 group-focus:delay-0 duration-150 ease-in-out overflow-hidden inline-flex select-none',\n                  variant === 'icon-grow' && !isPopoverOpen\n                    ? 'max-w-0 opacity-0 group-hover:opacity-100 group-hover:max-w-48 group-focus:opacity-100 group-focus:max-w-48 group-focus:pl-1.5 group-focus:-mr-0.5 group-hover:pl-1.5 group-hover:-mr-0.5'\n                    : 'max-w-48 pl-1.5 -mr-0.5 opacity-100'\n                )}\n              >\n                {labelText}\n                <ChevronDown className=\"h-4 w-4 text-muted-foreground transition-colors group-hover:text-foreground mt-0.25\" />\n              </span>\n            </BaseSyncButton>\n          </PopoverTrigger>\n          <PopoverConductor {...PopoverConductorProps} />\n        </>\n      )}\n    </Popover>\n  );\n}\n\nfunction LilDotGuy({ status }: { status?: GitPlatformSyncStatus }) {\n  if (!status || status === 'disconnected') {\n    return null;\n  }\n  return (\n    <div\n      className={cn(\n        'absolute -bottom-0.5 -right-0.5 h-2 w-2 rounded-full border border-background',\n        status === 'connected' && 'bg-green-500',\n        status === 'connected-syncing' && 'bg-yellow-500',\n        status === 'connected-warning' && 'bg-red-500'\n      )}\n    />\n  );\n}\n\nfunction BaseSyncButton({\n  children,\n  className,\n  status,\n  ...props\n}: React.ComponentProps<typeof Button> & {\n  status?: GitPlatformSyncStatus;\n}) {\n  return (\n    <Button\n      variant=\"outline\"\n      className={cn(\n        'group flex justify-between items-center gap-2 text-foreground px-2',\n        className\n      )}\n      {...props}\n    >\n      <div\n        className=\"relative flex justify-center items-center w-4 mx-0.25\"\n        aria-hidden\n      >\n        <GitHubIcon />\n        <LilDotGuy status={status} />\n      </div>\n      {children}\n    </Button>\n  );\n}\n\ntype PopoverConductorProps = Pick<\n  GitPlatformSyncProps,\n  | 'align'\n  | '__container'\n  | 'onHelpAction'\n  | 'onRepoCreateAction'\n  | 'repoName'\n  | 'repoDefaultName'\n  | 'repoNamePlaceholder'\n  | 'repoDefaultBranch'\n  | 'onRepoNameChange'\n  | 'onOwnerChange'\n  | 'codeStorageRepo'\n> & {\n  handleConnect: ({ onSuccess }: { onSuccess?: () => void }) => void;\n  connectionStatus: GitHubConnectionStatus;\n};\n\nfunction PopoverConductor({\n  align,\n  __container,\n  onHelpAction,\n  onRepoCreateAction,\n  onRepoNameChange,\n  onOwnerChange,\n  repoName,\n  repoDefaultName,\n  repoNamePlaceholder,\n  repoDefaultBranch,\n  handleConnect,\n  codeStorageRepo,\n  connectionStatus,\n}: PopoverConductorProps) {\n  let initialStep: Step = 'welcome';\n  if (codeStorageRepo) {\n    initialStep = 'manage';\n  } else if (connectionStatus === 'installed') {\n    initialStep = 'create';\n  }\n\n  const [step, setStep] = useState<Step>(initialStep);\n\n  useEffect(() => {\n    if (codeStorageRepo) {\n      setStep('manage');\n    } else if (connectionStatus === 'installed') {\n      setStep('create');\n    }\n  }, [codeStorageRepo, connectionStatus]);\n\n  // We want to make sure the container internal stuff doesn't blow up anyone's types\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const containerProp: any = __container ? { container: __container } : {};\n\n  return (\n    <PopoverContent className=\"w-[400px]\" align={align} {...containerProp}>\n      {step === 'welcome' ? (\n        <StepWelcome\n          // onAppInstalled={() => setStep('create')}\n          onHelpAction={onHelpAction}\n          handleConnect={handleConnect}\n          connectionStatus={connectionStatus}\n        />\n      ) : null}\n      {step === 'create' ? (\n        <StepCreate\n          __container={__container}\n          repoName={repoName}\n          repoDefaultName={repoDefaultName}\n          repoNamePlaceholder={repoNamePlaceholder}\n          repoDefaultBranch={repoDefaultBranch}\n          onRepoNameChange={onRepoNameChange}\n          onRepoCreateAction={onRepoCreateAction}\n          onOwnerChange={onOwnerChange}\n          handleConnect={handleConnect}\n          connectionStatus={connectionStatus}\n        />\n      ) : null}\n      {step === 'manage' ? (\n        <StepManage\n          __container={__container}\n          codeStorageRepo={codeStorageRepo as SyncedRepo}\n        />\n      ) : null}\n    </PopoverContent>\n  );\n}\n\ntype StepManageProps = {\n  codeStorageRepo: SyncedRepo;\n  /**\n   * @deprecated Internal use only, not guaranteed to be supported in the future\n   * @description The container to render the popover portal in, only used for docs. This requires\n   * modifying the shadcn Popover component to accept a container prop for the portal\n   */\n  __container?: React.ComponentProps<\n    typeof PopoverPrimitive.Portal\n  >['container'];\n};\n\nfunction StatusDot({ status }: { status: GitPlatformSyncStatus }) {\n  return (\n    <div\n      className={cn(\n        'h-1.5 w-1.5 rounded-full ring-2',\n        status === 'connected' && 'bg-green-500 ring-green-500/30',\n        status === 'connected-syncing' && 'bg-yellow-500 ring-yellow-500/30',\n        status === 'connected-warning' && 'bg-red-500 ring-red-500/30'\n      )}\n    />\n  );\n}\n\nfunction StepManage({ codeStorageRepo, __container }: StepManageProps) {\n  const { owners, getOwnerByName } = useOwners();\n  const [selectedOwnerId, setSelectedOwnerId] = useState<string | null>(null);\n\n  // TODO: This is inelegant. Since it'll necessarily need an extra render pass. We could move\n  // to an uncontrolled combobox and compute the value in the single pass, but idk.\n  useEffect(() => {\n    if (owners.length > 0) {\n      const owner = getOwnerByName(codeStorageRepo.repository.owner);\n      console.log(\n        'found owner by name',\n        codeStorageRepo.repository.owner,\n        owner\n      );\n      setSelectedOwnerId(owner?.id ?? null);\n    }\n  }, [owners, codeStorageRepo.repository.owner, getOwnerByName]);\n\n  const ownerOptions = useMemo(() => {\n    return generateOwnerOptions(owners);\n  }, [owners]);\n\n  // We want to make sure the container internal stuff doesn't blow up anyone's types\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const containerProp: any = __container ? { __container: __container } : {};\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"flex items-center gap-2 text-sm text-muted-foreground\">\n        <StatusDot status=\"connected\" />\n        Connected to GitHub\n      </div>\n      <div className=\"flex flex-col gap-4\">\n        <div className=\"flex flex-row gap-1\">\n          <Field className=\"w-fit flex-shrink-0 max-w-1/2 gap-1\">\n            <FieldLabel\n              htmlFor=\"storage-elements-github-owner\"\n              className=\"font-normal\"\n            >\n              Owner\n            </FieldLabel>\n            <ComboBox\n              id=\"storage-elements-github-owner\"\n              {...containerProp}\n              className=\"max-w-full\"\n              value={selectedOwnerId}\n              addItemLabel=\"Add GitHub account…\"\n              options={ownerOptions}\n            />\n          </Field>\n          <div\n            aria-hidden\n            className=\"font-normal self-end py-1 px-1 text-xl text-muted-foreground\"\n          >\n            /\n          </div>\n          <Field className=\"flex-1 gap-1\">\n            <FieldLabel\n              htmlFor=\"storage-elements-github-repo\"\n              className=\"font-normal\"\n            >\n              Repository\n            </FieldLabel>\n            <Input\n              autoFocus\n              spellCheck={false}\n              id=\"storage-elements-github-repo\"\n              name=\"repo-name\"\n              value={codeStorageRepo.repository.name}\n              readOnly\n            />\n          </Field>\n        </div>\n        <div>\n          <Field className=\"flex-1 gap-1.5\">\n            <FieldLabel\n              htmlFor=\"storage-elements-active-branch\"\n              className=\"font-normal\"\n            >\n              Active Branch\n            </FieldLabel>\n            <Input\n              autoFocus\n              spellCheck={false}\n              id=\"storage-elements-github-repo\"\n              name=\"repo-name\"\n              value={`${codeStorageRepo.repository.defaultBranch} (default)`}\n              readOnly\n            />\n          </Field>\n        </div>\n        <div className=\"text-xs text-muted-foreground\">\n          Changes are being automatically synced to this branch.\n        </div>\n      </div>\n    </div>\n  );\n}\n\ntype StepCreateProps = {\n  onOwnerChange?: (owner: string) => void;\n  onRepoNameChange?: (repoName: string) => void;\n  // onBranchChange?: (branch: string) => void;\n  connectionStatus: GitHubConnectionStatus;\n  onRepoCreateAction?: (repoData: RepositoryData) => void;\n  handleConnect: ({ onSuccess }: { onSuccess?: () => void }) => void;\n  repoName?: string;\n  repoDefaultName?: string;\n  repoNamePlaceholder?: string;\n  repoDefaultBranch?: string;\n  /**\n   * @deprecated Internal use only, not guaranteed to be supported in the future\n   * @description The container to render the popover portal in, only used for docs. This requires\n   * modifying the shadcn Popover component to accept a container prop for the portal\n   */\n  __container?: React.ComponentProps<\n    typeof PopoverPrimitive.Portal\n  >['container'];\n};\n\nfunction StepCreate({\n  onOwnerChange,\n  onRepoNameChange,\n  onRepoCreateAction,\n  handleConnect,\n  repoName,\n  repoDefaultName,\n  repoNamePlaceholder,\n  repoDefaultBranch,\n  __container,\n}: StepCreateProps) {\n  const { owners, status, getOwnerById, refresh } = useOwners();\n  const [selectedOwnerId, setSelectedOwnerId] = useState<string | null>(null);\n\n  // TODO: This is inelegant. Since it'll necessarily need an extra render pass. We could move\n  // to an uncontrolled combobox and compute the value in the single pass, but idk.\n  useEffect(() => {\n    if (owners.length > 0) {\n      setSelectedOwnerId(owners[0]?.id ?? null);\n    }\n  }, [owners]);\n\n  // We want to make sure the container internal stuff doesn't blow up anyone's types\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const containerProp: any = __container ? { __container: __container } : {};\n\n  const repoInputProps: React.ComponentProps<typeof Input> = useMemo(() => {\n    const rip: React.ComponentProps<typeof Input> = {};\n    if (repoName) {\n      rip.defaultValue = repoName;\n    } else if (repoDefaultName) {\n      rip.defaultValue = repoDefaultName;\n    }\n\n    const defaultPlaceholder = 'unique-repo-name…';\n    if (repoNamePlaceholder) {\n      rip.placeholder = repoNamePlaceholder ?? defaultPlaceholder;\n    } else {\n      rip.placeholder = defaultPlaceholder;\n    }\n    return rip;\n  }, [repoName, repoDefaultName, repoNamePlaceholder]);\n\n  const handleSubmit = useCallback(\n    (e: React.FormEvent<HTMLFormElement>) => {\n      e.preventDefault();\n      const formData = new FormData(e.currentTarget);\n      const repoName = formData.get('repo-name') as string;\n      // TODO: show errors in UI\n      if (!selectedOwnerId) {\n        console.warn('no selectedOwnerId');\n        return;\n      }\n\n      const owner = getOwnerById(selectedOwnerId);\n\n      if (!owner) {\n        console.warn('no owner found for selectedOwnerId', selectedOwnerId);\n        return;\n      }\n\n      const ownerLogin = owner.login;\n\n      if (!ownerLogin) {\n        console.warn(\n          'no ownerLogin found for selectedOwnerId',\n          selectedOwnerId,\n          owner\n        );\n        return;\n      }\n\n      if (!onRepoCreateAction) {\n        console.warn('no onRepoCreateAction provided');\n        return;\n      }\n\n      onRepoCreateAction({\n        owner: ownerLogin,\n        name: repoName,\n        branch: repoDefaultBranch,\n      });\n    },\n    [selectedOwnerId, getOwnerById, onRepoCreateAction, repoDefaultBranch]\n  );\n\n  const ownerOptions = useMemo(() => {\n    return generateOwnerOptions(owners);\n  }, [owners]);\n\n  return (\n    <div className=\"space-y-4\">\n      <div className=\"space-y-2\">\n        <h4 className=\"font-normal leading-none\">Sync to GitHub</h4>\n        <p className=\"text-sm text-muted-foreground\">\n          Create a new repository or choose an existing one to sync your\n          changes. We&apos;ll push changes with each new prompt you send.\n        </p>\n      </div>\n      {status === 'loading' ? (\n        <div className=\"flex justify-center items-center\">\n          <Loader2 className=\"h-4 w-4 animate-spin\" />\n        </div>\n      ) : null}\n      {status === 'error' ? (\n        <div className=\"flex justify-center items-center\">\n          <AlertCircle className=\"h-4 w-4\" />\n          <p className=\"text-sm text-red-500\">\n            Error loading GitHub accounts. Please try again.\n          </p>\n        </div>\n      ) : null}\n      {status === 'success' && owners.length === 0 ? (\n        <div className=\"flex justify-center items-center\">\n          <p className=\"text-sm text-muted-foreground\">\n            No GitHub accounts found. Please check the app permissions in your\n            GitHub settings.\n          </p>\n        </div>\n      ) : null}\n      {status === 'success' && owners.length > 0 ? (\n        <form onSubmit={handleSubmit}>\n          <div className=\"flex flex-col gap-4\">\n            <div className=\"flex flex-row gap-1\">\n              <Field className=\"w-fit flex-shrink-0 max-w-1/2 gap-1\">\n                <FieldLabel\n                  htmlFor=\"storage-elements-github-owner\"\n                  className=\"font-normal\"\n                >\n                  Owner\n                </FieldLabel>\n                <ComboBox\n                  id=\"storage-elements-github-owner\"\n                  {...containerProp}\n                  className=\"max-w-full\"\n                  value={selectedOwnerId}\n                  onValueChange={(value) => {\n                    console.log('owner value changed', value);\n                    setSelectedOwnerId(value);\n                    onOwnerChange?.(value);\n                  }}\n                  onAddItem={() => {\n                    handleConnect({\n                      onSuccess: () => {\n                        refresh();\n                      },\n                    });\n                  }}\n                  addItemLabel=\"Add GitHub account…\"\n                  options={ownerOptions}\n                />\n              </Field>\n              <div\n                aria-hidden\n                className=\"font-normal self-end py-1 px-1 text-xl text-muted-foreground\"\n              >\n                /\n              </div>\n              <Field className=\"flex-1 gap-1\">\n                <FieldLabel\n                  htmlFor=\"storage-elements-github-repo\"\n                  className=\"font-normal\"\n                >\n                  Repository\n                </FieldLabel>\n                <Input\n                  autoFocus\n                  spellCheck={false}\n                  id=\"storage-elements-github-repo\"\n                  name=\"repo-name\"\n                  {...repoInputProps}\n                  onChange={(e) => onRepoNameChange?.(e.target.value)}\n                />\n              </Field>\n            </div>\n            <Button size=\"lg\" className=\"w-full\" type=\"submit\">\n              Create Repository\n            </Button>\n          </div>\n        </form>\n      ) : null}\n    </div>\n  );\n}\n\ntype StepWelcomeProps = {\n  onAppInstalled?: () => void;\n  onHelpAction?: () => void;\n  handleConnect: ({ onSuccess }: { onSuccess?: () => void }) => void;\n  connectionStatus: GitHubConnectionStatus;\n};\n\nfunction StepWelcome({\n  onAppInstalled,\n  onHelpAction,\n  connectionStatus,\n  handleConnect,\n}: StepWelcomeProps) {\n  const isPendingConnection = connectionStatus === 'pending';\n  const hasError = connectionStatus === 'error';\n\n  // TODO: remove this\n  if (connectionStatus === 'installed') {\n    console.error(\n      'welcome step rendered with installed status, which shouldnt happen'\n    );\n  }\n\n  return (\n    <>\n      <div className=\"space-y-4\">\n        <div className=\"space-y-2\">\n          <h4 className=\"font-normal leading-none\">Connect to GitHub</h4>\n          <p className=\"text-sm text-muted-foreground\">\n            Sync your changes to GitHub to backup your code at every snapshot by\n            installing our app on your personal account or organization.\n          </p>\n          {hasError ? (\n            <p className=\"text-sm text-red-500\">\n              There was an error connecting to GitHub. Please try again.\n            </p>\n          ) : null}\n        </div>\n        <div className=\"flex flex-col gap-3\">\n          <Button\n            onClick={\n              isPendingConnection\n                ? undefined\n                : () => {\n                    handleConnect({\n                      onSuccess: onAppInstalled,\n                    });\n                  }\n            }\n            size=\"lg\"\n            className={cn(\n              'w-full',\n              isPendingConnection && 'opacity-80 pointer-events-none'\n            )}\n          >\n            <GitHubIcon />{' '}\n            {isPendingConnection\n              ? 'Connecting to GitHub…'\n              : 'Install GitHub App'}\n          </Button>\n          {onHelpAction ? (\n            <Button\n              onClick={onHelpAction}\n              size=\"lg\"\n              variant=\"secondary\"\n              className=\"w-full\"\n            >\n              <BookOpen /> Help me get started\n            </Button>\n          ) : null}\n        </div>\n      </div>\n    </>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/git-platform-sync/combobox.tsx",
      "content": "'use client';\n\nimport { Button } from '@/components/ui/button';\nimport {\n  Command,\n  CommandEmpty,\n  CommandGroup,\n  CommandInput,\n  CommandItem,\n  CommandList,\n  CommandSeparator,\n} from '@/components/ui/command';\nimport {\n  Popover,\n  PopoverContent,\n  PopoverTrigger,\n} from '@/components/ui/popover';\nimport { cn } from '@/lib/utils';\nimport * as PopoverPrimitive from '@radix-ui/react-popover';\nimport { CheckIcon, ChevronsUpDownIcon, PlusIcon } from 'lucide-react';\nimport * as React from 'react';\nimport { useState } from 'react';\n\nexport type ComboBoxProps = {\n  options: {\n    value: string;\n    label: string;\n    image?: string;\n  }[];\n  className?: string;\n  initialValue?: string;\n  /**\n   * Controlled value. When provided, the component operates in controlled mode.\n   */\n  value?: string;\n  /**\n   * Callback fired when the value changes. Receives the option's value (not label).\n   */\n  onValueChange?: (value: string) => void;\n  /**\n   * @default 'fit'\n   * @description Whether to combobox expands to its container, or fits to the width of the content\n   */\n  width?: 'fit' | 'full';\n  /**\n   * @default 'Add item…'\n   * @description The label to display for the \"Add item\" action\n   */\n  addItemLabel?: string;\n  /**\n   * Callback function to run when \"Add item\" is selected. If this is not defined,\n   * then the \"Add item\" action will not be shown.\n   */\n  onAddItem?: () => void;\n  /**\n   * @deprecated Internal use only, not guaranteed to be supported in the future\n   * @description The container to render the popover portal in, only used for docs. This requires\n   * modifying the shadcn Popover component to accept a container prop for the portal\n   */\n  __container?: React.ComponentProps<\n    typeof PopoverPrimitive.Portal\n  >['container'];\n} & Omit<React.ComponentProps<typeof Command>, 'value' | 'onValueChange'>;\n\nexport function ComboBox({\n  options,\n  className,\n  width = 'fit',\n  __container,\n  initialValue,\n  value: controlledValue,\n  onAddItem,\n  addItemLabel,\n  onValueChange,\n  ...props\n}: ComboBoxProps) {\n  // We want to make sure the container internal stuff doesn't blow up anyone's types\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const containerProp: any = __container ? { container: __container } : {};\n  const [open, setOpen] = useState(false);\n  const [internalValue, setInternalValue] = useState(\n    initialValue ?? options[0]?.value ?? null\n  );\n\n  // Use controlled value if provided, otherwise use internal state\n  const isControlled = controlledValue !== undefined;\n  const value = isControlled ? controlledValue : internalValue;\n\n  const selectedOption = value\n    ? options.find((option) => {\n        return option.value === value;\n      })\n    : null;\n\n  return (\n    <Popover open={open} onOpenChange={setOpen}>\n      <PopoverTrigger asChild>\n        <Button\n          variant=\"outline\"\n          role=\"combobox\"\n          aria-expanded={open}\n          className={cn(\n            'justify-between select-none gap-1.5',\n            width === 'fit' && '[&[role=combobox]]:w-fit',\n            width === 'full' && '[&[role=combobox]]:w-full',\n            className\n          )}\n        >\n          {selectedOption ? (\n            <span className=\"flex items-center gap-1.5 overflow-hidden\">\n              {selectedOption.image ? (\n                <img\n                  src={selectedOption.image}\n                  aria-hidden\n                  className=\"h-4 w-4 shrink-0 rounded-full\"\n                />\n              ) : null}\n              <span className=\"whitespace-nowrap overflow-hidden text-ellipsis\">\n                {selectedOption.label}\n              </span>\n            </span>\n          ) : null}\n          <ChevronsUpDownIcon className=\"h-4 w-4 shrink-0 opacity-50\" />\n        </Button>\n      </PopoverTrigger>\n      <PopoverContent\n        {...containerProp}\n        align=\"start\"\n        className=\"w-[220px] p-0\"\n      >\n        <Command {...props}>\n          {/* TODO: search is silly when there are only 1-5 options */}\n          <CommandInput placeholder=\"Search…\" />\n          <CommandList>\n            <CommandEmpty>No results</CommandEmpty>\n            <CommandGroup>\n              {options.map((option) => (\n                <CommandItem\n                  key={option.value}\n                  value={option.value}\n                  keywords={[option.label]}\n                  onSelect={(currentValue) => {\n                    const newValue = currentValue;\n\n                    // Update internal state if uncontrolled\n                    if (!isControlled) {\n                      setInternalValue(newValue);\n                    }\n\n                    // Always call onValueChange if provided\n                    if (newValue !== value) {\n                      onValueChange?.(newValue);\n                    }\n\n                    setOpen(false);\n                  }}\n                >\n                  {option.image ? (\n                    <img\n                      src={option.image}\n                      aria-hidden\n                      className=\"h-4 w-4 flex-shrink-0 rounded-full\"\n                    />\n                  ) : null}\n                  <span className=\"flex-1 whitespace-nowrap overflow-hidden text-ellipsis\">\n                    {option.label}\n                  </span>\n                  <CheckIcon\n                    className={cn(\n                      'mr-2 h-4 w-4 flex-shrink-0',\n                      value === option.value ? 'opacity-100' : 'opacity-0'\n                    )}\n                  />\n                </CommandItem>\n              ))}\n            </CommandGroup>\n            {onAddItem ? (\n              <>\n                <CommandSeparator />\n                <CommandGroup aria-label=\"Additional actions\">\n                  <CommandItem\n                    onSelect={() => {\n                      setOpen(false);\n                      onAddItem?.();\n                      return false;\n                    }}\n                  >\n                    <span className=\"flex items-center gap-1.5\">\n                      <PlusIcon className=\"h-4 w-4 flex-shrink-0\" />\n                      {addItemLabel ?? 'Add item…'}\n                    </span>\n                  </CommandItem>\n                </CommandGroup>\n              </>\n            ) : null}\n          </CommandList>\n        </Command>\n      </PopoverContent>\n    </Popover>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/git-platform-sync/github/icon.tsx",
      "content": "import { cn } from '@/lib/utils';\n\nexport const GitHubIcon = ({\n  className,\n  ...props\n}: React.SVGProps<SVGSVGElement>) => (\n  <svg\n    viewBox=\"0 0 16 16\"\n    fill=\"none\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    className={cn('h-full w-auto', className)}\n    {...props}\n  >\n    <path\n      d=\"M8 0C12.42 0 16 3.58 16 8C15.9996 9.6762 15.4735 11.3101 14.4958 12.6716C13.5182 14.0332 12.1381 15.0539 10.55 15.59C10.15 15.67 10 15.42 10 15.21C10 14.94 10.01 14.08 10.01 13.01C10.01 12.26 9.76 11.78 9.47 11.53C11.25 11.33 13.12 10.65 13.12 7.58C13.12 6.7 12.81 5.99 12.3 5.43C12.38 5.23 12.66 4.41 12.22 3.31C12.22 3.31 11.55 3.09 10.02 4.13C9.38 3.95 8.7 3.86 8.02 3.86C7.34 3.86 6.66 3.95 6.02 4.13C4.49 3.1 3.82 3.31 3.82 3.31C3.38 4.41 3.66 5.23 3.74 5.43C3.23 5.99 2.92 6.71 2.92 7.58C2.92 10.64 4.78 11.33 6.56 11.53C6.33 11.73 6.12 12.08 6.05 12.6C5.59 12.81 4.44 13.15 3.72 11.94C3.57 11.7 3.12 11.11 2.49 11.12C1.82 11.13 2.22 11.5 2.5 11.65C2.84 11.84 3.23 12.55 3.32 12.78C3.48 13.23 4 14.09 6.01 13.72C6.01 14.39 6.02 15.02 6.02 15.21C6.02 15.42 5.87 15.66 5.47 15.59C3.87664 15.0596 2.49073 14.041 1.50889 12.6786C0.527047 11.3163 -0.000880479 9.67931 1.10231e-06 8C1.10231e-06 3.58 3.58 0 8 0Z\"\n      fill=\"currentColor\"\n    />\n  </svg>\n);\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/git-platform-sync/github/github-app-connect.ts",
      "content": "'use client';\n\nimport { useCallback, useEffect, useMemo, useState } from 'react';\n\nexport interface GitHubAppConnectProps {\n  /**\n   * @description The slug of the GitHub app to connect to, this is different\n   * than the app id or the client id. It's what goes into the installation URL.\n   */\n  slug: string;\n  /**\n   * @default '${window.location.origin}/api/code-storage/github/callback'\n   * @description The URL to redirect to after the GitHub app is installed.\n   * If not provided, we wil use `window.location.origin` as the base url and\n   *  '/api/code-storage/github/callback' as the path.\n   */\n  redirectUrl?: string;\n  /**\n   * @default '/api/code-storage/github/installations'\n   * @description The URL to fetch GitHub app installations.\n   * If not provided, we will use `/api/code-storage/github/installations` as the path\n   * on the same origin that the current window is in.\n   */\n  installationsUrl?: string;\n}\n\nexport type Owner = {\n  id: string;\n  login: string;\n  type: string | null;\n  avatar_url: string | null;\n};\n\ntype InstallationsResponse = {\n  installations: Array<unknown>;\n  owners: Owner[];\n};\n\n// Cache configuration\nconst CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\nlet cachedInstallationsData: {\n  data: InstallationsResponse;\n  timestamp: number;\n} | null = null;\n\n// Track in-flight requests to prevent duplicate simultaneous requests\nlet pendingFetchInstallations: Promise<InstallationsResponse> | null = null;\n\nfunction isCacheValid(): boolean {\n  if (!cachedInstallationsData) return false;\n  return Date.now() - cachedInstallationsData.timestamp < CACHE_TTL_MS;\n}\n\n/**\n * Manually clear the cached installations data.\n * Useful when you know the data has changed.\n */\nexport function clearInstallationsCache(): void {\n  cachedInstallationsData = null;\n}\n\nexport async function fetchInstallations(\n  url = '/api/code-storage/github/installations',\n  signal?: AbortSignal\n): Promise<InstallationsResponse> {\n  // Return cached data if still valid\n  if (isCacheValid() && cachedInstallationsData) {\n    return cachedInstallationsData.data;\n  }\n\n  // If there's already a pending request, wait for it and return its result\n  if (pendingFetchInstallations) {\n    return pendingFetchInstallations;\n  }\n\n  // Create the request promise\n  const requestPromise = (async () => {\n    try {\n      const response = await fetch(url, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        signal,\n      });\n\n      // TODO: handle error cases better, especially if we can begin to pass more\n      // info about the error from the server\n      if (response.ok) {\n        const jsonResult = await response.json();\n        const data = jsonResult?.data;\n\n        if (data && 'installations' in data) {\n          const result: InstallationsResponse = {\n            installations: Array.isArray(data.installations)\n              ? data.installations\n              : [],\n            owners: Array.isArray(data.owners) ? data.owners : [],\n          };\n\n          // Cache the successful response\n          cachedInstallationsData = {\n            data: result,\n            timestamp: Date.now(),\n          };\n\n          return result;\n        } else {\n          console.warn(\n            'Warning: fetching installations - response has unexpected shape, falling back to empty array.'\n          );\n          return { installations: [], owners: [] };\n        }\n      } else {\n        throw new Error('installations endpoint not ok');\n      }\n    } finally {\n      // Clear the pending request when done (success or error)\n      pendingFetchInstallations = null;\n    }\n  })();\n\n  pendingFetchInstallations = requestPromise;\n  return requestPromise;\n}\n\nfunction hasInstallation(data: InstallationsResponse): boolean {\n  return data.installations.length > 0;\n}\n\nexport type GitHubConnectionStatus =\n  | 'uninitialized'\n  | 'pending'\n  | 'installed'\n  | 'error';\n\nexport type GitHubAppConnectionHandlerProps = {\n  onSuccess?: () => void;\n};\n\n/**\n * Encapsulates all imperative logic for managing GitHub App installation flow.\n * This class handles popup windows, message listeners, and polling in a way that\n * avoids React closure/stale reference issues.\n */\nclass GitHubAppConnector {\n  private popup: Window | null = null;\n  private checkInterval: ReturnType<typeof setInterval> | null = null;\n  private abortController = new AbortController();\n  private connectionStatus: GitHubConnectionStatus = 'uninitialized';\n  private stableId = crypto.randomUUID();\n\n  constructor(\n    private config: {\n      slug: string;\n      origin: string;\n      redirectUrl: string;\n      installationsUrl: string;\n    },\n    private onStatusChange: (status: GitHubConnectionStatus) => void\n  ) {}\n\n  private setStatus(status: GitHubConnectionStatus) {\n    this.connectionStatus = status;\n    this.onStatusChange(status);\n  }\n\n  private handleMessage = async (event: MessageEvent) => {\n    if (event.origin !== this.config.origin) {\n      return;\n    }\n\n    // If we're getting the right event type, and the unique\n    // state id matches this instance, we can proceed\n    if (\n      event.data.type === 'git-platform-sync-app-installed--github' &&\n      event.data.state === this.stableId\n    ) {\n      try {\n        const data = await fetchInstallations(\n          this.config.installationsUrl,\n          this.abortController.signal\n        );\n\n        if (hasInstallation(data)) {\n          this.setStatus('installed');\n        } else {\n          this.setStatus('uninitialized');\n        }\n      } catch {\n        this.setStatus('error');\n      }\n    }\n  };\n\n  async connect(props?: GitHubAppConnectionHandlerProps) {\n    const onSuccess = props?.onSuccess;\n    const width = 600;\n    const height = 700;\n    const left = window.screen.width / 2 - width / 2;\n    const top = window.screen.height / 2 - height / 2;\n\n    // Build the installation URL with redirect\n    const baseUrl = `https://github.com/apps/${this.config.slug}/installations/new`;\n    const url = `${baseUrl}?redirect_uri=${encodeURIComponent(this.config.redirectUrl)}&state=${encodeURIComponent(this.stableId)}`;\n\n    this.setStatus('pending');\n\n    this.popup = window.open(\n      url,\n      'code-storage-github-app-install',\n      `width=${width},height=${height},left=${left},top=${top},toolbar=no,menubar=no,location=no,status=no`\n    );\n\n    this.checkInterval = setInterval(async () => {\n      if (this.connectionStatus === 'installed') {\n        this.clearInterval();\n        onSuccess?.();\n      } else if (!this.popup || this.popup.closed) {\n        // Nothing new can happen if the pop-up is gone, so lets clear the interval\n        this.clearInterval();\n\n        // If the connection was closed while still in the 'pending' state,\n        // the user likely closed the pop-up before the handleMessage listener\n        // was able to receive a message (regardless of whether one was sent).\n        if (this.connectionStatus === 'pending') {\n          try {\n            // We need to determine if the app was installed or not.\n            const data = await fetchInstallations(\n              this.config.installationsUrl,\n              this.abortController.signal\n            );\n\n            if (hasInstallation(data)) {\n              this.setStatus('installed');\n              onSuccess?.();\n            } else {\n              this.setStatus('uninitialized');\n            }\n          } catch {\n            this.setStatus('error');\n          }\n        }\n      }\n    }, 1000);\n\n    // Use AbortController for automatic cleanup\n    window.addEventListener('message', this.handleMessage, {\n      signal: this.abortController.signal,\n    });\n  }\n\n  async fetchInstallationStatus() {\n    this.setStatus('pending');\n\n    try {\n      const data = await fetchInstallations(\n        this.config.installationsUrl,\n        this.abortController.signal\n      );\n      if (hasInstallation(data)) {\n        this.setStatus('installed');\n      } else {\n        this.setStatus('uninitialized');\n      }\n    } catch {\n      this.setStatus('error');\n    }\n  }\n\n  private clearInterval() {\n    if (this.checkInterval) {\n      clearInterval(this.checkInterval);\n      this.checkInterval = null;\n    }\n  }\n\n  destroy() {\n    // AbortController automatically removes all listeners and aborts any in-flight fetches\n    this.abortController.abort();\n    this.clearInterval();\n    this.popup?.close();\n    this.popup = null;\n  }\n}\n\nexport function useGitHubAppConnection({\n  slug,\n  redirectUrl: redirectUrlProp,\n  installationsUrl,\n}: GitHubAppConnectProps) {\n  const [status, setStatus] = useState<GitHubConnectionStatus>('uninitialized');\n\n  const origin = typeof window !== 'undefined' ? window.location.origin : '';\n  const redirectUrl =\n    redirectUrlProp ?? `${origin}/api/code-storage/github/callback`;\n  const installationsUrlResolved =\n    installationsUrl ?? '/api/code-storage/github/installations';\n\n  // Create the connector once - all config is captured at creation time.\n  // We intentionally create this only once to avoid recreating listeners and intervals.\n  // Config changes during the component lifecycle are not supported by design.\n  const connector = useMemo(() => {\n    return new GitHubAppConnector(\n      {\n        slug,\n        origin,\n        redirectUrl,\n        installationsUrl: installationsUrlResolved,\n      },\n      setStatus\n    );\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  useEffect(() => {\n    return () => connector.destroy();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Return stable callbacks that delegate to the connector\n  const handleConnect = useCallback(\n    (props?: GitHubAppConnectionHandlerProps) => {\n      connector.connect(props);\n    },\n    [connector]\n  );\n\n  const fetchInstallationStatus = useCallback(async () => {\n    await connector.fetchInstallationStatus();\n  }, [connector]);\n\n  const destroy = useCallback(() => {\n    connector.destroy();\n  }, [connector]);\n\n  return {\n    status,\n    handleConnect,\n    fetchInstallationStatus,\n    destroy,\n  };\n}\n",
      "type": "registry:component"
    },
    {
      "path": "registry/new-york/blocks/git-platform-sync/github/owners.ts",
      "content": "import { useEffect, useMemo, useState } from 'react';\n\nimport {\n  type Owner,\n  clearInstallationsCache,\n  fetchInstallations,\n} from './github-app-connect';\n\nexport type { Owner };\n\nexport type OwnersFetchStatus = 'loading' | 'error' | 'success';\n\ntype FetchOwnersResult = {\n  error: Error | null;\n  data:\n    | {\n        owners: Owner[];\n      }\n    | undefined;\n};\n\nasync function fetchOwners(signal?: AbortSignal): Promise<FetchOwnersResult> {\n  try {\n    const response = await fetchInstallations(\n      '/api/code-storage/github/installations',\n      signal\n    );\n    return {\n      error: null,\n      data: { owners: response.owners },\n    };\n  } catch (e) {\n    // Don't set error state if the request was aborted\n    if (e instanceof Error && e.name === 'AbortError') {\n      return { error: null, data: undefined };\n    }\n    return {\n      error: new Error('Failed to fetch owners'),\n      data: undefined,\n    };\n  }\n}\n\n/**\n * Manually clear the cached owners data.\n * Useful when you know the data has changed (e.g., after adding a new repository).\n */\nexport function clearOwnersCache(): void {\n  clearInstallationsCache();\n}\n\nexport function useOwners() {\n  const [owners, setOwners] = useState<Owner[]>([]);\n  const [status, setStatus] = useState<OwnersFetchStatus>('loading');\n  const [bustVersion, setBustVersion] = useState(0);\n\n  useEffect(() => {\n    const abortController = new AbortController();\n\n    const fetchEffect = async () => {\n      setStatus('loading');\n      const { error, data } = await fetchOwners(abortController.signal);\n\n      // Don't update state if the component was unmounted\n      if (abortController.signal.aborted) {\n        return;\n      }\n\n      if (error || data === null) {\n        setStatus('error');\n      } else if (data) {\n        setOwners(data.owners);\n        setStatus('success');\n      }\n    };\n\n    fetchEffect();\n\n    return () => {\n      abortController.abort();\n    };\n  }, [bustVersion]);\n\n  const ownerMap = useMemo(() => {\n    const map = new Map<string, Owner>();\n    for (const owner of owners) {\n      map.set(owner.id, owner);\n    }\n    return map;\n  }, [owners]);\n\n  return {\n    owners,\n    status,\n    getOwnerById: (id: string) => {\n      return ownerMap.get(id);\n    },\n    getOwnerByName: (name: string) => {\n      return owners.find((owner) => owner.login === name);\n    },\n    refresh: () => {\n      clearOwnersCache();\n      setBustVersion(bustVersion + 1);\n    },\n  };\n}\n\nexport function generateOwnerOptions(owners: Owner[]) {\n  return owners.map((owner) => ({\n    value: owner.id,\n    label: owner.login,\n    image: owner.avatar_url,\n  }));\n}\n",
      "type": "registry:component"
    }
  ]
}