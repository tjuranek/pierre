'use client';

import {
  IconBulbFill,
  IconCiWarningFill,
  IconInfoFill,
} from '@/components/icons';
import { Notice } from '@/components/ui/notice';
import type { PreloadedFileResult } from '@pierre/diffs/ssr';
import type { CSSProperties } from 'react';

import { DocsCodeExample } from '../DocsCodeExample';
import { ProseWrapper } from '../ProseWrapper';

interface WorkerPoolProps {
  helperVite: PreloadedFileResult<undefined>;
  helperNextJS: PreloadedFileResult<undefined>;
  vscodeLocalRoots: PreloadedFileResult<undefined>;
  vscodeWorkerUri: PreloadedFileResult<undefined>;
  vscodeInlineScript: PreloadedFileResult<undefined>;
  vscodeCsp: PreloadedFileResult<undefined>;
  vscodeGlobal: PreloadedFileResult<undefined>;
  vscodeBlobUrl: PreloadedFileResult<undefined>;
  vscodeFactory: PreloadedFileResult<undefined>;
  helperWebpack: PreloadedFileResult<undefined>;
  helperESBuild: PreloadedFileResult<undefined>;
  helperStatic: PreloadedFileResult<undefined>;
  helperVanilla: PreloadedFileResult<undefined>;
  vanillaUsage: PreloadedFileResult<undefined>;
  reactUsage: PreloadedFileResult<undefined>;
  apiReference: PreloadedFileResult<undefined>;
  cachingExample: PreloadedFileResult<undefined>;
  architectureASCII: PreloadedFileResult<undefined>;
}

export function WorkerPool({
  helperVite,
  helperNextJS,
  vscodeLocalRoots,
  vscodeWorkerUri,
  vscodeInlineScript,
  vscodeCsp,
  vscodeGlobal,
  vscodeBlobUrl,
  vscodeFactory,
  helperWebpack,
  helperESBuild,
  helperStatic,
  helperVanilla,
  vanillaUsage,
  reactUsage,
  apiReference,
  cachingExample,
  architectureASCII,
}: WorkerPoolProps) {
  return (
    <ProseWrapper>
      <h2>Worker Pool</h2>
      <Notice variant="warning" icon={<IconCiWarningFill />}>
        This feature is experimental and undergoing active development. There
        may be bugs and the API is subject to change.
      </Notice>
      <Notice icon={<IconBulbFill />}>
        Import worker utilities from <code>@pierre/diffs/worker</code>.
      </Notice>
      <p>
        By default, syntax highlighting runs on the main thread using Shiki. If
        you’re rendering large files or many diffs, this can cause a bottleneck
        on your JavaScript thread resulting in jank or unresponsiveness. To work
        around this, we’ve provided some APIs to run all syntax highlighting in
        worker threads. The main thread will still attempt to render plain text
        synchronously and then apply the syntax highlighting when we get a
        response from the worker threads.
      </p>
      <p>
        Basic usage differs a bit depending on if you’re using React or Vanilla
        JS APIs, so continue reading for more details.
      </p>

      <h3>Setup</h3>
      <p>
        One unfortunate side effect of using Web Workers is that different
        bundlers and environments require slightly different approaches to
        create a Web Worker. You’ll need to create a function that spawns a
        worker that’s appropriate for your environment and bundler and then pass
        that function to our provided APIs.
      </p>
      <p>
        Lets begin with the <code>workerFactory</code> function. We’ve provided
        some examples for common use cases below.
      </p>
      <Notice variant="warning" icon={<IconCiWarningFill />}>
        Only the Vite and NextJS examples have been tested by us. Additional
        examples were generated by AI. If any of them are incorrect, please let
        us know.
      </Notice>

      <h4 data-toc-ignore>Vite</h4>
      <p>
        You may need to explicitly set the <code>worker.format</code> option in
        your{' '}
        <a
          href="https://vite.dev/config/worker-options#worker-format"
          target="_blank"
          rel="noopener noreferrer"
        >
          Vite Config
        </a>{' '}
        to <code>'es'</code>.{' '}
      </p>
      <DocsCodeExample {...helperVite} />

      <h4 data-toc-ignore>NextJS</h4>
      <Notice variant="warning" icon={<IconCiWarningFill />}>
        Workers only work in client components. Ensure your function has the{' '}
        <code>'use client'</code> directive if using App Router.
      </Notice>
      <DocsCodeExample {...helperNextJS} />

      <h4 data-toc-ignore>VS Code Webview Extension</h4>
      <p>
        VS Code webviews have special security restrictions that require a
        different approach. You’ll need to configure both the extension side (to
        expose the worker file) and the webview side (to load it via blob URL).
      </p>
      <p>
        <strong>Extension side:</strong> Add the worker directory to{' '}
        <code>localResourceRoots</code> in your <code>getWebviewOptions()</code>
        :
      </p>
      <DocsCodeExample {...vscodeLocalRoots} />
      <p>
        Create the worker URI in <code>_getHtmlForWebview()</code>. Note: use{' '}
        <code>worker-portable.js</code> instead of <code>worker.js</code> — the
        portable version is designed for environments where ES modules aren't
        supported in web workers.
      </p>
      <DocsCodeExample {...vscodeWorkerUri} />
      <p>Pass the URI to the webview via an inline script in your HTML:</p>
      <DocsCodeExample {...vscodeInlineScript} />
      <p>
        Your Content Security Policy must include <code>worker-src</code> and{' '}
        <code>connect-src</code>:
      </p>
      <DocsCodeExample {...vscodeCsp} />
      <p>
        <strong>Webview side:</strong> Declare the global type for the URI:
      </p>
      <DocsCodeExample {...vscodeGlobal} />
      <p>Fetch the worker code and create a blob URL:</p>
      <DocsCodeExample {...vscodeBlobUrl} />
      <p>
        Create the <code>workerFactory</code> function:
      </p>
      <DocsCodeExample {...vscodeFactory} />

      <h4 data-toc-ignore>Webpack 5</h4>
      <DocsCodeExample {...helperWebpack} />

      <h4 data-toc-ignore>esbuild</h4>
      <DocsCodeExample {...helperESBuild} />

      <h4 data-toc-ignore>Rollup / Static Files</h4>
      <p>
        If your bundler doesn’t have special worker support, build and serve the
        worker file statically:
      </p>
      <DocsCodeExample {...helperStatic} />

      <h4 data-toc-ignore>Vanilla JS (No Bundler)</h4>
      <p>
        For projects without a bundler, host the worker file on your server and
        reference it directly:
      </p>
      <DocsCodeExample {...helperVanilla} />

      <h3>Usage</h3>
      <p>
        With your <code>workerFactory</code> function created, you can integrate
        it with our provided APIs. In React, you’ll want to pass this{' '}
        <code>workerFactory</code> to a{' '}
        <code>&lt;WorkerPoolContextProvider&gt;</code> so all components can
        inherit the pool automatically. If you’re using the Vanilla JS APIs, we
        provide a <code>getOrCreateWorkerPoolSingleton</code> helper that
        ensures a single pool instance that you can then manually pass to all
        your File/FileDiff instances.
      </p>

      <Notice icon={<IconInfoFill />} variant="warning">
        When using the worker pool, the <code>theme</code>,{' '}
        <code>lineDiffType</code>, and <code>tokenizeMaxLineLength</code> render
        options are controlled by <code>WorkerPoolManager</code>, not individual
        components. Passing these options into component instances will be
        ignored. To change render options after WorkerPoolManager instantiates,
        use the <code>setRenderOptions()</code> method on the{' '}
        <code>WorkerPoolManager</code>. <strong>Note:</strong> Changing render
        options will force all mounted components to re-render and will clear
        the render cache.
      </Notice>

      <h4 data-toc-ignore>React</h4>
      <p>
        Wrap your component tree with <code>WorkerPoolContextProvider</code>{' '}
        from <code>@pierre/diffs/react</code>. All <code>FileDiff</code> and{' '}
        <code>File</code> components nested within will automatically use the
        worker pool for syntax highlighting.
      </p>
      <p>
        The <code>WorkerPoolContextProvider</code> will automatically spin up or
        shut down the worker pool based on its react lifecycle. If you have
        multiple context providers, they will all share the same pool, and
        termination won’t occur until all contexts are unmounted.
      </p>

      <Notice variant="warning" icon={<IconCiWarningFill />}>
        Workers only work in client components. Ensure your function has the{' '}
        <code>'use client'</code> directive if using App Router.
      </Notice>

      <p>
        To change themes or other render options dynamically, use the{' '}
        <code>useWorkerPool()</code> hook to access the pool manager and call{' '}
        <code>setRenderOptions()</code>.
      </p>
      <DocsCodeExample {...reactUsage} />

      <h4 data-toc-ignore>Vanilla JS</h4>
      <p>
        Use <code>getOrCreateWorkerPoolSingleton</code> to spin up a singleton
        worker pool. Then pass that as the second argument to <code>File</code>{' '}
        and/or <code>FileDiff</code>. When you are done with the worker pool,
        you can use <code>terminateWorkerPoolSingleton</code> to free up
        resources.
      </p>
      <p>
        To change themes or other render options dynamically, call{' '}
        <code>setRenderOptions(options)</code> on the pool instance.
      </p>
      <DocsCodeExample {...vanillaUsage} />

      <h3>Render Cache</h3>
      <Notice variant="warning" icon={<IconCiWarningFill />}>
        This is an experimental feature being validated in production use cases.
        The API is subject to change.
      </Notice>
      <p>
        The worker pool can cache rendered AST results to avoid redundant
        highlighting work. When a file or diff has a <code>cacheKey</code>,
        subsequent requests with the same key will return cached results
        immediately instead of reprocessing through a worker. This works
        automatically for both React and Vanilla JS APIs.
      </p>
      <Notice icon={<IconInfoFill />}>
        Caching is enabled per-file/diff by setting a <code>cacheKey</code>{' '}
        property. Files and diffs without a <code>cacheKey</code> will not be
        cached. The cache also validates against render options — if options
        like theme or line diff type change, the cached result is skipped and
        re-rendered.
      </Notice>
      <DocsCodeExample {...cachingExample} />

      <h3>API Reference</h3>
      <p>
        These methods are exposed for advanced use cases. In most scenarios, you
        should use the <code>WorkerPoolContextProvider</code> for React or pass
        the pool instance via the <code>workerPool</code> option for Vanilla JS
        rather than calling these methods directly.
      </p>
      <DocsCodeExample {...apiReference} />

      <h3>Architecture</h3>
      <p>
        The worker pool manages a configurable number of worker threads that
        each initialize their own Shiki highlighter instance. Tasks are
        distributed across available workers, with queuing when all workers are
        busy.
      </p>
      <DocsCodeExample
        {...architectureASCII}
        className="inline-block"
        style={
          {
            '--diffs-line-height': '15px',
          } as CSSProperties
        }
      />
    </ProseWrapper>
  );
}
