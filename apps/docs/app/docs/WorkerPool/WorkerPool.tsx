'use client';

import {
  IconBulbFill,
  IconCiWarningFill,
  IconInfoFill,
} from '@/components/icons';
import { Notice } from '@/components/ui/notice';
import type { PreloadedFileResult } from '@pierre/precision-diffs/ssr';
import type { CSSProperties } from 'react';

import { DocsCodeExample } from '../DocsCodeExample';

interface WorkerPoolProps {
  helperVite: PreloadedFileResult<undefined>;
  helperNextJS: PreloadedFileResult<undefined>;
  helperWebpack: PreloadedFileResult<undefined>;
  helperESBuild: PreloadedFileResult<undefined>;
  helperStatic: PreloadedFileResult<undefined>;
  helperVanilla: PreloadedFileResult<undefined>;
  vanillaUsage: PreloadedFileResult<undefined>;
  reactUsage: PreloadedFileResult<undefined>;
  apiReference: PreloadedFileResult<undefined>;
  architectureASCII: PreloadedFileResult<undefined>;
}

export function WorkerPool({
  helperVite,
  helperNextJS,
  helperWebpack,
  helperESBuild,
  helperStatic,
  helperVanilla,
  vanillaUsage,
  reactUsage,
  apiReference,
  architectureASCII,
}: WorkerPoolProps) {
  return (
    <section className="space-y-4">
      <h2>Worker Pool</h2>
      <Notice icon={<IconBulbFill />}>
        Import worker utilities from <code>@pierre/precision-diffs/worker</code>
        .
      </Notice>
      <p>
        By default, syntax highlighting runs on the main thread using Shiki. If
        you’re rendering large files or many diffs, this can cause a bottleneck
        on your JavaScript thread resulting in jank or unresponsiveness. To work
        around this, we’ve provided some APIs to run all syntax highlighting in
        worker threads. The main thread will still attempt to render plain text
        synchronously and then apply the syntax highlighting when we get a
        response from the worker threads.
      </p>
      <p>
        Basic usage differs a bit depending on if you’re using React or Vanilla
        JS APIs, so continue reading for more details.
      </p>

      <h3>Setup</h3>
      <p>
        One unfortunate side effect of using Web Workers is that different
        bundlers and environments require slightly different approaches to
        create a Web Worker. You’ll need to create a function that spawns a
        worker that’s appropriate for your environment and bundler and then pass
        that function to our provided APIs.
      </p>
      <p>
        Lets begin with the <code>workerFactory</code> function. We’ve provided
        some examples for common use cases below.
      </p>
      <Notice variant="warning" icon={<IconCiWarningFill />}>
        Only the Vite and NextJS examples have been tested by us. Additional
        examples were generated by AI. If any of them are incorrect, please let
        us know.
      </Notice>

      <h4 data-toc-ignore>Vite</h4>
      <p>
        You may need to explicitly set the <code>worker.format</code> option in
        your{' '}
        <a
          href="https://vite.dev/config/worker-options#worker-format"
          target="_blank"
          rel="noopener noreferrer"
        >
          Vite Config
        </a>{' '}
        to <code>'es'</code>.{' '}
      </p>
      <DocsCodeExample {...helperVite} />

      <h4 data-toc-ignore>NextJS</h4>
      <Notice variant="warning" icon={<IconCiWarningFill />}>
        Workers only work in client components. Ensure your function has the{' '}
        <code>'use client'</code> directive if using App Router.
      </Notice>

      <DocsCodeExample {...helperNextJS} />

      <h4 data-toc-ignore>Webpack 5</h4>
      <DocsCodeExample {...helperWebpack} />

      <h4 data-toc-ignore>esbuild</h4>
      <DocsCodeExample {...helperESBuild} />

      <h4 data-toc-ignore>Rollup / Static Files</h4>
      <p>
        If your bundler doesn’t have special worker support, build and serve the
        worker file statically:
      </p>
      <DocsCodeExample {...helperStatic} />

      <h4 data-toc-ignore>Vanilla JS (No Bundler)</h4>
      <p>
        For projects without a bundler, host the worker file on your server and
        reference it directly:
      </p>
      <DocsCodeExample {...helperVanilla} />

      <h3>Usage</h3>
      <p>
        With your <code>workerFactory</code> function created, you can integrate
        it with our provided APIs. In React, you’ll want to pass this{' '}
        <code>workerFactory</code> to a{' '}
        <code>&lt;WorkerPoolContextProvider&gt;</code> so all components can
        inherit the pool automatically. If you’re using the Vanilla JS APIs, we
        provide a <code>getOrCreateWorkerPoolSingleton</code> helper that
        ensures a single pool instance that you can then manually pass to all
        your File/FileDiff instances.
      </p>

      <Notice icon={<IconInfoFill />}>
        When using the worker pool, theme settings are controlled by the pool
        manager, not individual component props. Any <code>theme</code> options
        passed to <code>File</code> or <code>FileDiff</code> components will be
        ignored. To change the theme, use the <code>setTheme()</code> method on
        the pool manager. All connected instances will automatically re-render
        with the new theme.
      </Notice>

      <h4 data-toc-ignore>React</h4>
      <p>
        Wrap your component tree with <code>WorkerPoolContextProvider</code>{' '}
        from <code>@pierre/precision-diffs/react</code>. All{' '}
        <code>FileDiff</code> and <code>File</code> components nested within
        will automatically use the worker pool for syntax highlighting.
      </p>
      <p>
        The <code>WorkerPoolContextProvider</code> will automatically spin up or
        shut down the worker pool based on its react lifecycle. If you have
        multiple context providers, they will all share the same pool, and
        termination won’t occur until all contexts are unmounted.
      </p>

      <Notice variant="warning" icon={<IconCiWarningFill />}>
        Workers only work in client components. Ensure your function has the{' '}
        <code>'use client'</code> directive if using App Router.
      </Notice>

      <p>
        To change themes dynamically, use the <code>useWorkerPool()</code> hook
        to access the pool manager and call <code>setTheme()</code>.
      </p>
      <DocsCodeExample {...reactUsage} />

      <h4 data-toc-ignore>Vanilla JS</h4>
      <p>
        Use <code>getOrCreateWorkerPoolSingleton</code> to spin up a singleton
        worker pool. Then pass that as the second argument to <code>File</code>{' '}
        and/or <code>FileDiff</code>. When you are done with the worker pool,
        you can use <code>terminateWorkerPoolSingleton</code> to free up
        resources.
      </p>
      <p>
        To change themes dynamically, call{' '}
        <code>workerPool.setTheme(theme)</code> on the pool instance.
      </p>
      <DocsCodeExample {...vanillaUsage} />

      <h3>API Reference</h3>
      <p>
        These methods are exposed for advanced use cases. In most scenarios, you
        should use the <code>WorkerPoolContextProvider</code> for React or pass
        the pool instance via the <code>workerPool</code> option for Vanilla JS
        rather than calling these methods directly.
      </p>
      <DocsCodeExample {...apiReference} />

      <h3>Architecture</h3>
      <p>
        The worker pool manages a configurable number of worker threads that
        each initialize their own Shiki highlighter instance. Tasks are
        distributed across available workers, with queuing when all workers are
        busy.
      </p>
      <DocsCodeExample
        {...architectureASCII}
        className="inline-block"
        style={
          {
            '--pjs-line-height': '15px',
          } as CSSProperties
        }
      />
    </section>
  );
}
